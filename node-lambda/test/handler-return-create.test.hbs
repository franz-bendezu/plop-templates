$<imports>
import IBase{{pascalCase name}} from '../../src/{{kebabCase moduleName}}/interface/base-{{kebabCase name}}.interface';$<code>$<tests>
    it('should successfully save a new {{camelCase name}}', async () => {
        const responseData: {{pascalCase name}}DTO = {
            id: 1,
            name: 'test',
            savedAt: new Date('2023-01-01'),
            modifiedAt: new Date('2023-01-01'),
            savedBy: 'user',
            modifiedBy: 'user-mod',
            {{#each paramsProperties}}
            {{name}}: '{{value}}',
            {{/each}}
        };
        const mockSave = jest.spyOn({{camelCase name}}Controller, 'save').mockResolvedValue(responseData);
        
        const data: Required<IBase{{pascalCase name}}> = {
            name: 'test',
            {{#each paramsProperties}}
            {{name}}: '{{value}}',
            {{/each}}
        };

        const result = await invokeHandler({ body: JSON.stringify(data) });

        expect(result).toBeInstanceOf(ApiGatewayResponse);
        expect(result).toEqual({
            statusCode: 201,
            body: JSON.stringify({
                mensaje: '{{pascalCase name}} creado',
                data: mockData,
                estado: ValidationMessage.SUCCESS,
            }),
        });

        expect(mockSave).toHaveBeenCalledWith(params);
        });

    it('should throw ValidationError when required fields are missing', async () => {
        const result = await invokeHandler({ 
            body: JSON.stringify({})
        });

        expect(result).toBeInstanceOf(ApiGatewayResponse);
        expect(result).toEqual({
            statusCode: 400,
            body: JSON.stringify({
                mensaje: StatusMessages.BAD_REQUEST,
                estado: ValidationMessage.BAD,
            }),
        });
    });

    it('should throw RuntimeError when save operation fails', async () => {
        const mockError = new RuntimeError({ statusMessage: 'Save failed' });
        const mockSave = jest.spyOn({{camelCase name}}Controller, 'save')
            .mockRejectedValue(mockError);

        const result = await invokeHandler({
            body: JSON.stringify({ name: 'test' })
        });

        expect(mockSave).toHaveBeenCalled();
        expect(result).toEqual({
            statusCode: 500,
            body: JSON.stringify({
                mensaje: StatusMessages.INTERNAL_SERVER_ERROR,
                estado: ValidationMessage.BAD,
            }),
        });
    });